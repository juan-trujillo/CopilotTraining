name: Deploy Slidev Presentations to GitHub Pages

on:
  push:
    branches:
      - main
    paths:
      - "slides/**"
      - ".github/workflows/deploy-slides.yml"
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Restore previous build cache
        uses: actions/cache@v4
        with:
          path: ./slides/dist
          key: slides-dist-${{ github.sha }}
          restore-keys: |
            slides-dist-

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Cache node_modules
        id: npm-cache
        uses: actions/cache@v4
        with:
          path: ./slides/node_modules
          key: npm-${{ runner.os }}-${{ hashFiles('slides/package.json') }}

      - name: Install dependencies
        if: steps.npm-cache.outputs.cache-hit != 'true'
        working-directory: ./slides
        run: npm install

      - name: Cache Playwright browsers
        id: playwright-cache
        uses: actions/cache@v4
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ hashFiles('slides/package.json') }}

      - name: Install Playwright browsers
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        working-directory: ./slides
        run: npx playwright install chromium --with-deps

      - name: Install Playwright system deps only
        if: steps.playwright-cache.outputs.cache-hit == 'true'
        run: npx playwright install-deps chromium

      - name: Build slides
        working-directory: ./slides
        shell: bash {0}
        run: |
          mkdir -p dist/workshop dist/tech-talks dist/exec-talks dist/.build-logs

          MAX_JOBS=4
          PIDS=()
          LABELS=()
          FAILED=0
          SKIPPED=0

          # Extract 'updated' date from frontmatter (first 20 lines)
          get_updated() {
            head -20 "$1" | sed -n 's/^updated: *//p'
          }

          # Load previous build manifest
          declare -A PREV_UPDATED
          if [ -f "dist/.build-manifest.json" ]; then
            while IFS='=' read -r key val; do
              PREV_UPDATED["$key"]="$val"
            done < <(python3 -c "
          import json
          with open('dist/.build-manifest.json') as f:
              m = json.load(f)
          for k, v in m.items():
              print(f'{k}={v}')
          " 2>/dev/null || true)
            echo "üìã Loaded manifest with ${#PREV_UPDATED[@]} entries"
          else
            echo "üìã No manifest ‚Äî building all slides"
          fi

          # Decide if a slide needs building: compare updated date vs manifest
          needs_build() {
            local KEY="$1"
            local CURRENT_DATE="$2"
            [ ! -d "dist/${KEY}" ] && return 0                    # No dist output
            [ -z "${PREV_UPDATED[$KEY]+x}" ] && return 0          # Not in manifest
            [ -z "$CURRENT_DATE" ] && return 0                    # No updated field
            [ "$CURRENT_DATE" != "${PREV_UPDATED[$KEY]}" ]        # Date changed
          }

          # Build with retry
          build_slide() {
            local SLIDE_FILE="$1"
            local CATEGORY=$(dirname "$SLIDE_FILE")
            local BASENAME=$(basename "$SLIDE_FILE" .md)
            local LOG_FILE="dist/.build-logs/${CATEGORY}--${BASENAME}.log"

            for ATTEMPT in 1 2; do
              [ $ATTEMPT -eq 1 ] && echo "üî® Building ${CATEGORY}/${BASENAME}..." \
                                 || echo "üîÑ Retrying ${CATEGORY}/${BASENAME} (attempt 2)..."
              if npx slidev build "$SLIDE_FILE" \
                --base "/CopilotTraining/${CATEGORY}/${BASENAME}/" \
                --out "$(pwd)/dist/${CATEGORY}/${BASENAME}" \
                > "$LOG_FILE" 2>&1; then
                return 0
              fi
            done
            echo "::error::Build failed for ${CATEGORY}/${BASENAME}. Log:"
            tail -20 "$LOG_FILE"
            return 1
          }

          # Wait for a parallel slot to free up
          wait_for_slot() {
            while [ ${#PIDS[@]} -ge $MAX_JOBS ]; do
              NEW_PIDS=(); NEW_LABELS=()
              for i in "${!PIDS[@]}"; do
                if kill -0 "${PIDS[$i]}" 2>/dev/null; then
                  NEW_PIDS+=("${PIDS[$i]}"); NEW_LABELS+=("${LABELS[$i]}")
                else
                  wait "${PIDS[$i]}" && echo "‚úÖ ${LABELS[$i]} built successfully" \
                                     || { echo "‚ùå ${LABELS[$i]} FAILED"; FAILED=1; }
                fi
              done
              PIDS=("${NEW_PIDS[@]}"); LABELS=("${NEW_LABELS[@]}")
              [ ${#PIDS[@]} -ge $MAX_JOBS ] && sleep 1
            done
          }

          # Iterate all slides ‚Äî build only what's needed
          declare -A NEW_MANIFEST
          for SLIDE_FILE in workshop/*.md tech-talks/*.md exec-talks/*.md; do
            [ -f "$SLIDE_FILE" ] || continue
            CATEGORY=$(dirname "$SLIDE_FILE")
            BASENAME=$(basename "$SLIDE_FILE" .md)
            KEY="${CATEGORY}/${BASENAME}"
            CURRENT_UPDATED=$(get_updated "$SLIDE_FILE")

            # Always track in manifest
            [ -n "$CURRENT_UPDATED" ] && NEW_MANIFEST["$KEY"]="$CURRENT_UPDATED"

            # Skip if updated date matches and dist exists
            if ! needs_build "$KEY" "$CURRENT_UPDATED"; then
              echo "‚è≠Ô∏è  ${KEY} (updated: ${CURRENT_UPDATED}) ‚Äî up to date"
              SKIPPED=$((SKIPPED + 1))
              continue
            fi

            wait_for_slot
            build_slide "$SLIDE_FILE" &
            PIDS+=($!)
            LABELS+=("${KEY}")
          done

          # Wait for remaining builds
          for i in "${!PIDS[@]}"; do
            wait "${PIDS[$i]}" && echo "‚úÖ ${LABELS[$i]} built successfully" \
                               || { echo "‚ùå ${LABELS[$i]} FAILED"; FAILED=1; }
          done

          [ $FAILED -eq 1 ] && { echo "‚ùå Some builds failed"; exit 1; }

          # Write manifest for next run
          python3 -c "
          import json, sys
          manifest = {}
          for line in sys.stdin:
              if '=' in line:
                  k, v = line.strip().split('=', 1)
                  manifest[k] = v
          with open('dist/.build-manifest.json', 'w') as f:
              json.dump(manifest, f, indent=2, sort_keys=True)
          " <<< "$(for key in "${!NEW_MANIFEST[@]}"; do echo "${key}=${NEW_MANIFEST[$key]}"; done)"

          # Copy index and 404
          cp index-custom.html dist/index.html
          cp 404.html dist/404.html

          BUILT=${#LABELS[@]}
          echo "üìä ${BUILT} built, ${SKIPPED} skipped (up to date)"

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./slides/dist

  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
