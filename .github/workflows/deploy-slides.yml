name: Deploy Slidev Presentations to GitHub Pages

on:
  push:
    branches:
      - main
    paths:
      - "slides/**"
      - ".github/workflows/deploy-slides.yml"
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2 # Need previous commit to detect changes

      - name: Detect changed slides
        id: changes
        working-directory: ./slides
        run: |
          echo "üîç Detecting changed files..."

          # Get changed files between HEAD^ and HEAD
          # For workflow_dispatch or first commit, build all
          if ! git rev-parse HEAD^ >/dev/null 2>&1; then
            echo "üì¶ First commit or shallow clone - building all slides"
            echo "full_rebuild=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          CHANGED_FILES=$(git diff --name-only HEAD^ HEAD -- . || echo "")

          # Check if shared files or workflow changed (require full rebuild)
          SHARED_PATTERNS="slides/package.json|slides/package-lock.json|slides/style.css|slides/global-top.vue|slides/global-bottom.vue|slides/layouts/|slides/components/|slides/setup/|\.github/workflows/deploy-slides\.yml"
          if echo "$CHANGED_FILES" | grep -qE "$SHARED_PATTERNS"; then
            echo "üîÑ Shared files or workflow changed - full rebuild required"
            echo "full_rebuild=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Extract changed slide .md files (paths include slides/ prefix from git)
          CHANGED_SLIDES=$(echo "$CHANGED_FILES" | grep -E "^slides/(workshop|tech-talks|exec-talks)/.*\.md$" | sed 's#^slides/##' || echo "")

          if [ -z "$CHANGED_SLIDES" ]; then
            echo "üì≠ No slide files changed"
            echo "full_rebuild=false" >> $GITHUB_OUTPUT
            echo "changed_slides=" >> $GITHUB_OUTPUT
          else
            echo "üìù Changed slides:"
            echo "$CHANGED_SLIDES"
            echo "full_rebuild=false" >> $GITHUB_OUTPUT
            # Convert to space-separated for easier iteration
            echo "changed_slides<<EOF" >> $GITHUB_OUTPUT
            echo "$CHANGED_SLIDES" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Download previous build from gh-pages
        id: download
        continue-on-error: true
        run: |
          echo "üì• Downloading previous build from gh-pages branch..."
          mkdir -p ./slides/dist

          # Clone only the gh-pages branch (shallow)
          if git ls-remote --exit-code --heads origin gh-pages >/dev/null 2>&1; then
            git clone --depth 1 --branch gh-pages https://github.com/${{ github.repository }}.git ./previous-build
            cp -r ./previous-build/* ./slides/dist/ 2>/dev/null || true
            rm -rf ./previous-build
            echo "‚úÖ Previous build restored"
            echo "needs_rebuild=false" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è No gh-pages branch found - will build all slides"
            echo "needs_rebuild=true" >> $GITHUB_OUTPUT
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Cache node_modules
        id: npm-cache
        uses: actions/cache@v4
        with:
          path: ./slides/node_modules
          key: npm-${{ runner.os }}-${{ hashFiles('slides/package.json') }}

      - name: Install dependencies
        if: steps.npm-cache.outputs.cache-hit != 'true'
        working-directory: ./slides
        run: npm install

      - name: Cache Playwright browsers
        id: playwright-cache
        uses: actions/cache@v4
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ hashFiles('slides/package.json') }}

      - name: Install Playwright browsers
        if: steps.playwright-cache.outputs.cache-hit != 'true'
        working-directory: ./slides
        run: npx playwright install chromium --with-deps

      - name: Install Playwright system deps only
        if: steps.playwright-cache.outputs.cache-hit == 'true'
        run: npx playwright install-deps chromium

      - name: Build presentations (incremental)
        if: steps.changes.outputs.full_rebuild != 'true' && steps.changes.outputs.changed_slides != '' && steps.download.outputs.needs_rebuild != 'true'
        working-directory: ./slides
        run: |
          echo "üöÄ Building changed slides only..."

          # Ensure dist directories exist
          mkdir -p dist/workshop dist/tech-talks dist/exec-talks

          # Build only changed slides
          mkdir -p dist/.build-logs
          while IFS= read -r SLIDE_FILE; do
            if [ -n "$SLIDE_FILE" ] && [ -f "$SLIDE_FILE" ]; then
              # Extract category and basename
              CATEGORY=$(dirname "$SLIDE_FILE")
              BASENAME=$(basename "$SLIDE_FILE" .md)
              LOG_FILE="dist/.build-logs/${CATEGORY}--${BASENAME}.log"

              echo "üî® Building ${CATEGORY}/${BASENAME}..."

              if ! npx slidev build "$SLIDE_FILE" \
                --base "/CopilotTraining/${CATEGORY}/${BASENAME}/" \
                --out "$(pwd)/dist/${CATEGORY}/${BASENAME}" \
                > "$LOG_FILE" 2>&1; then
                echo "::error::Build failed for ${CATEGORY}/${BASENAME}. See log:"
                tail -20 "$LOG_FILE"
                exit 1
              fi

              echo "‚úÖ ${CATEGORY}/${BASENAME} built successfully"
            fi
          done <<< "${{ steps.changes.outputs.changed_slides }}"

          # Ensure index.html and 404.html exist
          if [ ! -f dist/index.html ]; then
            cp index-custom.html dist/index.html
          fi
          cp 404.html dist/404.html

          echo "‚ú® Incremental build complete!"

      - name: Build all presentations (full rebuild)
        if: steps.changes.outputs.full_rebuild == 'true' || steps.download.outputs.needs_rebuild == 'true'
        working-directory: ./slides
        shell: bash {0}
        run: |
          echo "üöÄ Building all Slidev presentations..."

          mkdir -p dist/workshop dist/tech-talks dist/exec-talks

          MAX_JOBS=4
          PIDS=()
          LABELS=()
          FAILED=0
          SKIPPED=0
          REBUILT=0

          # Check if a slide has status: archived in frontmatter
          is_archived() {
            head -20 "$1" | grep -q '^status: archived$'
          }

          # Extract 'updated' date from frontmatter
          get_updated() {
            head -20 "$1" | sed -n 's/^updated: *//p'
          }

          # Load previous build manifest (written by prior deploy)
          MANIFEST_FILE="dist/.build-manifest.json"
          declare -A PREV_UPDATED
          if [ -f "$MANIFEST_FILE" ]; then
            while IFS='=' read -r key val; do
              PREV_UPDATED["$key"]="$val"
            done < <(python3 -c "
          import json, sys
          with open('$MANIFEST_FILE') as f:
              m = json.load(f)
          for k, v in m.items():
              print(f'{k}={v}')
          " 2>/dev/null || true)
            echo "üìã Loaded build manifest with ${#PREV_UPDATED[@]} entries"
          else
            echo "üìã No previous build manifest found ‚Äî building all"
          fi

          # Check if slide needs rebuilding based on 'updated' field
          needs_build() {
            local SLIDE_FILE="$1"
            local CATEGORY=$(dirname "$SLIDE_FILE")
            local BASENAME=$(basename "$SLIDE_FILE" .md)
            local KEY="${CATEGORY}/${BASENAME}"

            # No previous build dir? Must build
            [ ! -d "dist/${KEY}" ] && return 0

            # No previous manifest entry? Must build
            [ -z "${PREV_UPDATED[$KEY]+x}" ] && return 0

            # Compare updated dates
            local CURRENT_UPDATED=$(get_updated "$SLIDE_FILE")
            [ -z "$CURRENT_UPDATED" ] && return 0  # No updated field? Build to be safe

            if [ "$CURRENT_UPDATED" = "${PREV_UPDATED[$KEY]}" ]; then
              return 1  # Same date ‚Äî skip
            fi
            return 0  # Different date ‚Äî rebuild
          }

          # Track new manifest entries
          declare -A NEW_MANIFEST

          build_slide() {
            local SLIDE_FILE="$1"
            local CATEGORY=$(dirname "$SLIDE_FILE")
            local BASENAME=$(basename "$SLIDE_FILE" .md)
            local LOG_FILE="dist/.build-logs/${CATEGORY}--${BASENAME}.log"
            local MAX_RETRIES=2
            local ATTEMPT=0

            mkdir -p "$(dirname "$LOG_FILE")"

            while [ $ATTEMPT -lt $MAX_RETRIES ]; do
              ATTEMPT=$((ATTEMPT + 1))
              if [ $ATTEMPT -eq 1 ]; then
                echo "üî® Building ${CATEGORY}/${BASENAME}..."
              else
                echo "üîÑ Retrying ${CATEGORY}/${BASENAME} (attempt ${ATTEMPT}/${MAX_RETRIES})..."
              fi

              if npx slidev build "$SLIDE_FILE" \
                --base "/CopilotTraining/${CATEGORY}/${BASENAME}/" \
                --out "$(pwd)/dist/${CATEGORY}/${BASENAME}" \
                > "$LOG_FILE" 2>&1; then
                return 0
              fi
            done

            echo "::error::Build failed for ${CATEGORY}/${BASENAME} after ${MAX_RETRIES} attempts. See log:"
            tail -20 "$LOG_FILE"
            return 1
          }

          wait_for_slot() {
            while [ ${#PIDS[@]} -ge $MAX_JOBS ]; do
              NEW_PIDS=()
              NEW_LABELS=()
              for i in "${!PIDS[@]}"; do
                if kill -0 "${PIDS[$i]}" 2>/dev/null; then
                  NEW_PIDS+=("${PIDS[$i]}")
                  NEW_LABELS+=("${LABELS[$i]}")
                else
                  wait "${PIDS[$i]}" && echo "‚úÖ ${LABELS[$i]} built successfully" || { echo "‚ùå ${LABELS[$i]} FAILED"; FAILED=1; }
                fi
              done
              PIDS=("${NEW_PIDS[@]}")
              LABELS=("${NEW_LABELS[@]}")
              [ ${#PIDS[@]} -ge $MAX_JOBS ] && sleep 1
            done
          }

          # Queue all slide builds (skip archived & unchanged slides)
          for SLIDE_FILE in workshop/*.md tech-talks/*.md exec-talks/*.md; do
            if [ -f "$SLIDE_FILE" ]; then
              CATEGORY=$(dirname "$SLIDE_FILE")
              BASENAME=$(basename "$SLIDE_FILE" .md)
              KEY="${CATEGORY}/${BASENAME}"
              CURRENT_UPDATED=$(get_updated "$SLIDE_FILE")

              # Track in manifest regardless of build/skip
              [ -n "$CURRENT_UPDATED" ] && NEW_MANIFEST["$KEY"]="$CURRENT_UPDATED"

              # Skip archived slides with existing builds
              if is_archived "$SLIDE_FILE"; then
                if [ -d "dist/${KEY}" ]; then
                  echo "‚è≠Ô∏è  Skipping archived: ${KEY} (reusing previous build)"
                  SKIPPED=$((SKIPPED + 1))
                  continue
                else
                  echo "‚ö†Ô∏è  Archived slide ${KEY} has no previous build ‚Äî rebuilding"
                fi
              # Skip unchanged slides with existing builds
              elif ! needs_build "$SLIDE_FILE"; then
                echo "‚è≠Ô∏è  Skipping unchanged: ${KEY} (updated: ${CURRENT_UPDATED})"
                SKIPPED=$((SKIPPED + 1))
                continue
              fi

              wait_for_slot
              build_slide "$SLIDE_FILE" &
              PIDS+=($!)
              LABELS+=("${CATEGORY}/${BASENAME}")
              REBUILT=$((REBUILT + 1))
            fi
          done

          # Wait for remaining jobs
          for i in "${!PIDS[@]}"; do
            wait "${PIDS[$i]}" && echo "‚úÖ ${LABELS[$i]} built successfully" || { echo "‚ùå ${LABELS[$i]} FAILED"; FAILED=1; }
          done

          [ $FAILED -eq 1 ] && { echo "‚ùå Some builds failed"; exit 1; }

          # Write build manifest for next run
          python3 -c "
          import json, sys
          manifest = {}
          for line in sys.stdin:
              k, v = line.strip().split('=', 1)
              manifest[k] = v
          with open('dist/.build-manifest.json', 'w') as f:
              json.dump(manifest, f, indent=2, sort_keys=True)
          " <<< "$(for key in "${!NEW_MANIFEST[@]}"; do echo "${key}=${NEW_MANIFEST[$key]}"; done)"
          echo "üìã Build manifest written with ${#NEW_MANIFEST[@]} entries"

          TOTAL=$((REBUILT + SKIPPED))
          echo "üìä ${TOTAL} slides total: ${REBUILT} built, ${SKIPPED} skipped (archived/unchanged)"

          # Copy custom index.html and 404.html to dist root
          echo "üìÑ Copying index.html and 404.html to dist root..."
          cp index-custom.html dist/index.html
          cp 404.html dist/404.html

          echo "‚ú® All presentations built successfully!"

      - name: Verify build output
        if: steps.changes.outputs.full_rebuild != 'true' && steps.changes.outputs.changed_slides == '' && steps.download.outputs.needs_rebuild != 'true'
        working-directory: ./slides
        run: |
          echo "‚è≠Ô∏è No slide changes detected - using previous build"
          # Verify we have a valid dist directory
          if [ ! -d dist ] || [ ! -f dist/index.html ]; then
            echo "‚ùå Error: No valid dist directory found and no slides to build"
            exit 1
          fi
          echo "‚úÖ Previous build is valid"

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./slides/dist

  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
